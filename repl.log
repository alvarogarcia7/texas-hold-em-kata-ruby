"a".tr
"a".tr_s
ri
:help "a".to_s
:help to_s
:help String::to_s
:help String.to_s
:help
help
ri "a".to_s
ri String.to_s
ri String:to_s
ri String::to_s
ri
ri NilClass
ri String
puts "a"
"a".tr
"a".tr("a2", "b"
  "a".tr("a2", "b")
"a".tr("a2", "b")
"a".tr("\s", "")
"a   ".tr("\s", "")
"a   ".strip
"a    \n".strip
"a b".split " "
load parser.rb
load "parser.rb"
.pwd
load "src/parser.rb"
Card.new("1a")
Card.new("1a")==Card.new("1a")
Card.new("1a")===Card.new("1a")
load "src/parser.rb"
Card.new("1a")===Card.new("1a")
Card.new("1a")==Card.new("1a")
vals = "1234"
vals.split
vals.split("")
vals.split("").contains?("1")
vals.split("").items
vals.split("")
vals_ = ["1", "2", "3", "4"]
vals_.include?("1")
"a2"[1]
"a2"[0]
"a1".split " "
load "src/parser.rb"
Card.new("4s")
Reader.new("4s").convert
Reader.new("4s").convert.inspect
Reader.new("4s").convert[0]
Reader.new("4s").convert
hand = Reader.new("4s").convert
hand.cards
hand.cards[0]
load "src/parser.rb"
hand = Reader.new("4s").convert
hand.cards[0]
hand.cards
load "src/parser.rb"
Hand.new(Card.new("4s"))
Hand.new(Card.new("4s")).inspect
Card.new("4s")
[Card.new("4s")]
Hand.new([Card.new("4s")]).inspect
Hand.new([Card.new("4s")]).to_s
Hand.new([Card.new("4s")])
[Card.new("4s")]
[Card.new("4s")].inspect
Card.new("4s").inspect
Hand.new([Card.new("4s")]).to_s
Reader.new("4s").convert
Reader.new("4s").convert.inspect
Reader.new("4s").convert
Reader.new("4s").convert[0]
Reader.new("4s").convert
Reader.new("4s")
{ :a => Reader.new("4s").convert}
{ :a => Reader.new("4s").convert, :kicker => nil}
{ :a => Reader.new("4s").convert, :kicker => nil} == true
{ :a => Reader.new("4s").convert, :kicker => nil}.inspect
{ :a => Reader.new("4s").convert, :kicker => nil}[:a]
{ :a => Reader.new("4s").convert, :kicker => nil}[:a].inspect
load "src/parser.rb"
Reader.new("4s").convert
Reader.new("4s").convert.cards
Reader.new("4s 2s 3s").convert.cards
load "src/parser.rb"
Reader.new("4s 2s 3s").convert.cards
load "src/parser.rb"
Reader.new("4s 2s 3s").convert.cards
load "src/parser.rb"
Reader.new("4s 2s 3s").convert.cards"
Reader.new("4s 2s 3s").convert.cards
load "src/parser.rb"
Reader.new("4s 2s 3s").convert.cards
Reader.new("4s 2s 3s").convert
Hand.new(Card.new("4s"), Card.new("5s"))
Hand.new([Card.new("4s"), Card.new("5s")])
Hand.new([Card.new("4s"), Card.new("5s")]).cards
Hand.from("4s 5s")
load "src/parser.rb"
Hand.from('4s 5s')
Hand.from('4s 5s').cards
load "src/parser.rb"
rule = Rule::HIGH_CARD
initial_hand = Hand.from('4s 5s')
expected_result = {used: Hand.from('5s'), kicker: Hand.from('4s')}
rule.apply initial_hand
expected_result
expected_result[:used]
expected_result[:used].cards
expected_result[:kicker].cards
expected_result[:kicker]
expected_result[:kicker].to_s
expected_result[:kicker].inspect
expected_result[:kicker]
k=expected_result[:kicker]
k.display
def a do yield end
def a do yield end;
def a do; yield; end
def a; yield; end
a
a { puts 1 }
def a; puts "a"; end
a { puts 1 }
def a &b; puts "a"; end
a { puts 1 }
def a &b; yield b; end
a { puts 1 }
def a b; yield b; end
a { puts 1 }
def a &b; yield b; end
load "src/parser.rb"
Rule::HIGH_CARD
r = Rule::HIGH_CARD
r.apply {puts 1}
r.apply 1 {puts 1}
r.apply 1, {puts 1}
r.apply 1, { puts 1 }
r.apply 1
load "src/parser.rb"
Rule::HIGH_CARD
Rule::HIGH_CARD.block
Rule::HIGH_CARD.block.inspect
Rule::HIGH_CARD.block.display
load "src/parser.rb"
Rule::HIGH_CARD
Rule::HIGH_CARD.block
load "src/parser.rb"
Rule::HIGH_CARD.block 1
Rule::HIGH_CARD.block
yield Rule::HIGH_CARD.block 1
def a c, &b; yield b, c; end
a {puts 1}
a 2, {puts 1}
a { |x| puts x }
a 2, { |x| puts x }
a(2, { |x| puts x })
a(2, { |x| puts x; })
a(2, { |x| puts x })
def method_with_block_arguments
  yield("Jim")
end
load "src/parser.rb"
Rule.new.apply [0,1], {|x| puts x}
Rule.new.apply [0,1], do |x| puts x end
Rule.new.apply [0,1], do { |x| puts x } end
Rule.new.apply [0,1], do |x| puts x  end
r = Rule.new
r.apply 1, do |x| puts x end
r.apply 1, (do |x| puts x end)
r.apply 1, (do |x|  end)
r.apply 1, (do |x| x end)
r.apply 1, (do |x| x+1 end)
(do |x| x+1 end)
do |x| x+1 end
def x x+1 end
def x x+1; end
def x; x+1; end
[1,2,3].collect! x
[1,2,3].collect! do |x| x+1 end
a= do |x| x+1 end
method(:a)
method(:a).class
method(:x)
method(:x).class
[1,2,3].collect! method(:x)
def x x; x+1; end
[1,2,3].collect! method(:x)
def x y; y+1; end
[1,2,3].collect! method(:x)
[1,2,3].collect! do |n| method(:x).call(n) end
load "src/parser.rb"
r.apply [0,1], do |x| x[1] end
r.apply [0,1], (do |x|; x[1]; end)
load "src/parser.rb"
r.apply [0,1], seccond
r.apply [0,1], do |x| seccond(x) end
r.apply [0,1], do |x| method(:seccond).call(x) end
r.apply([0,1], do |x| method(:seccond).call(x) end)
s
s = method(:seccond)
r.apply([0,1], do |x| s.call(x) end)
s == s
def x y; y+1; end
s1 = def x y; y+1; end
s2 = def x y; y+1; end
s1 == s2
s2 = def x y; y+2; end
s1 == s2
s2 = def z y; y+2; end
s1 == s2
s1.inspect
s1
s1.call(1)
x
x(1)
z(1)
{ |x| x[1] }.call [0,1]
({ |x| x[1] }).call [0,1]
({ |x| x[1] }).call([0,1])
)
({ |x| x[1] }).call([0,1])
(do |x| x[1] end).call([0,1])
(do |x| x[1] end)
(do |x|; x[1]; end)
(do |x| x[1]; end)
(do |x| x[1]; end;)
def h x; x[1]; end
h [1,2]
def x; y[1]; end
x [1,2]
lambda |x| x[1] end
lambda |x| x[1]; end
lambda |x|; x[1]; end
lambda {|x| x[1]}
lambda {|x| x[1]}.call [0,1]
load "src/parser.rb"
Rule::HIGH_CARD.apply Hand.from "4a"
Rule::HIGH_CARD.apply Hand.from "4s"
Rule::HIGH_CARD.apply( Hand.from "4s")
Hand.from "4s"
Hand.from "4s".cards
(Hand.from "4s").cards
load "src/parser.rb"
Rule::HIGH_CARD.apply( Hand.from "4s")
load "src/parser.rb"
Rule::HIGH_CARD.apply( Hand.from "4s")
load "src/parser.rb"
Rule::HIGH_CARD.apply( Hand.from "4s")
Rule::HIGH_CARD.apply( Hand.from "4s 5s")
Hand.from "4s 5s"
Hand.from "4s 5s".cards
(Hand.from "4s 5s").card
(Hand.from "4s 5s").cards
Card::FACES
Card::VALID_VALUES
Card::VALID_VALUES.map
vals = ["4", "5"]
Card::VALID_VALUES.iterate_with_index
Card::VALID_VALUES.each_with_index
Card::VALID_VALUES.each_with_index |x, i| if vals.contains?(x) then i else nil end
Card::VALID_VALUES.each_with_index do |x, i| if vals.contains?(x) then i else nil end
Card::VALID_VALUES.each_with_index do |x, i| if vals.contains?(x) then [i,x] else nil end
vals.include? Card::VALID_VALUES[0]
vals.include? Card::VALID_VALUES[1]
Card::VALID_VALUES.map |x| vals.include? x end
Card::VALID_VALUES.map { |x| vals.include? x}
Card::VALID_VALUES.map { |x| [vals.include? x, x]}
Card::VALID_VALUES.map { |x| return [vals.include? x, x]}
Card::VALID_VALUES.map { |x| return [vals.include? x, x] }
Card::VALID_VALUES.map { |x| return vals.include? x, x }
Card::VALID_VALUES.map { |x| [[vals.include? x), x] }
Card::VALID_VALUES.map { |x| [(vals.include? x), x] }
Card::VALID_VALUES.map { |x| [(vals.include? x), x] }.select {|x| x[0]==true}
load "src/parser.rb"
Rule::HIGH_CARD.apply( Hand.from "4s 5s")
Rule::HIGH_CARD.apply(Hand.from "4s 5s")
load "src/parser.rb"
Rule::HIGH_CARD.apply(Hand.from "4s 5s")
Hand.from "4s 5s"
Hand.from "4s 5s".cards
(Hand.from "4s 5s").card
(Hand.from "4s 5s").cards
Rule::HIGH_CARD.apply(Hand.from "4s 5s")
load "src/parser.rb"
Rule::HIGH_CARD.apply(Hand.from "4s 5s")
load "src/parser.rb"
Rule::HIGH_CARD.apply(Hand.from "4s 5s")
Reader.new("4s 2s 3s").convert
Reader.new("4s 2s 3s").convert.cards
Reader.new("4s 2s 3s").convert.cards[0].class
Reader.new("4s 2s 3s").convert.cards[0].face
Reader.new("4s 2s 3s").convert.cards[0].face.class
load "src/parser.rb"
Rule::HIGH_CARD.apply(Hand.from "4s 5s")
load "src/parser.rb"
Rule::HIGH_CARD.apply(Hand.from "4s 5s")
Card::VALID_VALUES.index "A"
load "src/parser.rb"
Rule::HIGH_CARD.apply(Hand.from "4s 5s")
["A", "A", "B"].delete "A"
x = ["A", "A", "B"]; x.delete "A"
x
load "src/parser.rb"
nil == nil
nil == Object.class
load "src/parser.rb"
EmptyHand.new
EmptyHand.new.class
EmptyHand.new.class.is_a?(EmptyHand.class)
EmptyHand.new.class.is_a?(Object.class)
EmptyHand.new.class.is_a?(Hand.class)
Hand.new.class.is_a?(EmptyHand.class)
Hand.new([]).class.is_a?(EmptyHand.class)
Hand.new([nil]).class.is_a?(EmptyHand.class)
Object.class.is_a?(EmptyHand.class)
ri is_a?
Hand.new([nil]).class.kind_of?(EmptyHand.class)
Hand.new([nil]).class.instance_of?(EmptyHand.class)
EmptyHand==EmptyHand
EmptyHand.new()==EmptyHand.new()
EmptyHand.new==EmptyHand.new
load "src/parser.rb"
EmptyHand.new==EmptyHand.new
load "src/parser.rb"
EmptyHand.new==EmptyHand.new
EmptyHand.new==Hand::EMPTY
EmptyHand.new.is_a?(EmptyHand)
EmptyHand.new.is_a?(EmptyHand.class)
EmptyHand.new.is_a?(EmptyHand)
EmptyHand.new.is_a?(HandHand)
EmptyHand.new.is_a?(Hand)
EmptyHand.new.is_a?(Card)
load "src/parser.rb"
EmptyHand.new == EmptyHand.new
EmptyHand.new == Hand.new([])
load "src/parser.rb"
expect
[3,3,4].group_by{|f| f}
[3,3,4].group_by{|f| f}.values
[3,3,4].group_by{|f| f}.values.map{|x| [x, x.count]}
[2,3].first
[2,3].second
"123".extend""
ri each
q

#Session ending at: 2015-10-12T18:26:51+02:00

#Session ending at: 2015-10-12T18:26:58+02:00

#Session ending at: 2015-10-12T18:27:20+02:00

#Session ending at: 2015-10-12T18:27:24+02:00

#Session ending at: 2015-10-12T18:28:06+02:00
[1,2,3].push[1]
x= [1,2,3]
x.push[1]
x
x.push[1]
x
x>>[1]
x<<[1]
x<<<[1]
x.push[1]
c
x=[1,2,3]
x.transpose
x.extend
x.extend([1])
x.concat [2, nil, 4]
[].empty?
[] || [1]
![]. || [1]
1 and 2
1 and 4
true and false
[1,2].unshift
[1,2].remove_at(0)
[1,2].delete_at(0)
[1,2].index 1
[1,2].min
[1,2m1].min
[1,2,1].min
[1,2,1].select {|x| x ==1}
[1,2,1].select {|x| x ==1}.first
[1,2,1].last
Array.const_set
Array.constants
load "src/paser.rb"
.pwd
load "./src/paser.rb"
load "src/parser.rb"
Rule.constants
Rule.constants.reverse
a,b= [[1,2],[1,2]].zip
a,b= [[1,2],[1,2]].zip(|x, y| [x, y])
a,b= [[1,2],[1,2]].zip{|x, y| [x, y]}
a,b= [[1,2],[1,2]].zip{|x, y| return [x, y]}
a,b= [[1,2],[1,2]].zip{|x| [y]}
a,b= [[1,2],[1,2]].zip{|x| [x]}
a
b
help [].zip
help zip
a,b= [].zip([1,2],[3,4])
a,b= [[]].zip([1,2],[3,4])
a,b= [[]].zip([1,2],[1,2])
a,b= [[],[]].zip([1,2],[1,2])
a,b= [nil, nil].zip([1,2],[1,2])
[nil, nil].zip([1,2],[1,2])
[0, 0].zip([1,2],[1,2])
[[1,2],[1,2]].transpose
[[1,2,4],[1,2,4]].transpose
[[1,2],[1,2],[1,2],[1,2]].transpose
[0,1].second
[0,1].sec
[0,1].se
{a: 1, b:1}.transpose
{a: 1, b:1}.group_by
{a: 1, b:1}.group_by{|x| x}
{a: 1, b:1}.group_by{|x| x.key}
{a: 1, b:1}.group_by{|x| p x}
{a: 1, b:1}.group_by{|x| x.first}
{a: 1, b:1}.group_by{|x| [x.first, x[1]}
{a: 1, b:1}.group_by{|x| [x.first, x[1]]}
{a: 1, b:1}.group_by{|x| [x.first, x[0]]}
{a: 1, b:1}.group_by{|x| [x.first]}
{a: 1, b:1}.group_by{|x| x.first}
{a: 1, b:1}.group_by{|x| x.first}.flatten
{a: 1, b:1}.group_by{|x| x.first}.keys
{a: 1, b:1}.group_by{|x| x.first}.each{|x,y| p x}
{a: 1, b:1}.group_by{|x| x.first}.each{|x,y| p y}
{a: 1, b:1}.group_by{|x| x.first}
[:a, :b].map { |x| 1}
[:a, :b].map { |x| [x, 1]}
[:a, :b].map { |x| [x, 1] }.group_by
[:a, :b].map { |x| [x, 1] }.group_by{|x| x}
[:a, :b].map { |x| [x, 1] }.group_by{|x| x.first}
[:a, :b].map { |x| [x, 1] }.group_by{|x,j| x.first}
[:a, :b].map { |x| [x, 1] }.group_by{|x, j| x.first}
[:a, :b].map { |x| [x, 1] }.group_by{|x, l| x.first}
[:a, :b].map { |x| [x, 1] }.group_by{|x, l| x}
[:a, :b].map { |x| [x, 1] }.group_by{|x, l| l}
[:a, :b].map { |x| [x, 1] }.group_by{|x, l| x}
[:a, :b].map { |x| [x, 1] }.group_by{|x, l, m| x}
[:a, :b].map { |x| [x, 1] }.group_by{|x, l, m| m}
[:a, :b].map { |x| [x, 1] }.group_by{|x, l| l}
[2, 1].group_by{|x| x.even?}
[2, 1].group_by{|x| [2, x.even?]}
[2, 1].group_by{|x,i| [2, x.even?]}
[2, 1].group_by{|x,i| [x.even?]}
[2, 1].group_by{|x,i| [i, x.even?]}
[2, 1].map{|x| {x: x.even?}}
[2, 1].map{|x| {x: x.even?}}[0]
[2, 1].map{|x| {x: x.even?}}.to_set
[2, 1].map{|x| {x: x.even?}}.flatten
[2, 1].map{|x| {x: x.even?}}.to_set
[2, 1].map{|x| {x: x.even?}}.to_set.each {|x| p x}
[2, 1].map{|x| {x: x.even?}}
[2, 1].map{|x| {x => x.even?}}
[2, 1].map{|x| {x => x.even?}}.to_set
[2, 1].map{|x| {x => x.even?}}.to_set.each
[2, 1].map{|x| {x => x.even?}}.to_set.each{|x| p x}
[2, 1,3].map{|x| {x => x.even?}}.to_set.each{|x| p x}
[2, 1,2].map{|x| {x => x.even?}}.to_set.each{|x| p x}
eval("[2, 1].map{|x| {x => x.even?}}.to_set.each{|x| p x}")
lines = []; File.open('./repl.log') do |file| lines = file.map {|l| l.strip} end
lines[1]
eval(lines[1])
eval(lines[0])
eval(lines[2])
eval(lines[3])
lines[3]
lines = []; File.open('./repl.log') do |file| lines = file.map {|l| l} end; []
lines[1]
p lines[1]
lines = []; File.open('./repl.log') do |file| lines = file.map {|l| l} end; []
File.open( './repl.log' ) do |f| p "#{f.lineno}: #{line}" end
File.foreach( './repl.log' ) do |line|
  p "#{line}"
end
lines = []
File.foreach( './repl.log' ) do |line|
  lines << "#{line}"
end
lines
File.foreach( './repl.log' ) do |line|
  lines << line
end
lines
p lines[0]
lines[0].escape
lines[0]
source load
source :load
source "load"
lines = []; File.foreach( './repl.log' ) do |line|  lines << "#{line}" end
lines
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.trim end
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip end
lines
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip.replace("\"","") end
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip.replace("\\"","") end
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip.replace('\"',"") end
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip.replace('\"','') end
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip.replace('\\"','') end
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip.sub('\\"','') end
lines
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip.sub('\"','') end
lines[0]
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip.gsub('\"','') end
lines[0]
"\"a"
"\"a".sub('\"','')
"\"a".sub('\\"','')
"\"a".sub('\/"','')
"\"a".sub('\"','')
"\"a".sub("\"",'')
lines = []; File.foreach( './repl.log' ) do |line|  lines << line.strip.gsub("\"",'') end
lines[0]
eval(lines[0])
eval(lines[1])
eval(lines[2])
eval(lines[3])
eval(lines[4])
eval(lines[5])
eval(lines[6])
eval(lines[7])
eval(lines[8])
eval(lines[9])
eval(lines109])
eval(lines[10])
eval(lines[11])
eval(lines[12])
eval(lines[13])
eval(lines[14])
